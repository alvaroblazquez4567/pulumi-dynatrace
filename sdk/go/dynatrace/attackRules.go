// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dynatrace

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-dynatrace/sdk/go/dynatrace/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AttackRules struct {
	pulumi.CustomResourceState

	// Step 2: Define attack control for chosen criteria
	AttackHandling AttackRulesAttackHandlingOutput `pulumi:"attackHandling"`
	// Step 1: Define criteria
	Criteria AttackRulesCriteriaOutput `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringOutput `pulumi:"insertAfter"`
	// Step 3: Leave comment
	Metadata AttackRulesMetadataOutput `pulumi:"metadata"`
}

// NewAttackRules registers a new resource with the given unique name, arguments, and options.
func NewAttackRules(ctx *pulumi.Context,
	name string, args *AttackRulesArgs, opts ...pulumi.ResourceOption) (*AttackRules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AttackHandling == nil {
		return nil, errors.New("invalid value for required argument 'AttackHandling'")
	}
	if args.Criteria == nil {
		return nil, errors.New("invalid value for required argument 'Criteria'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Metadata == nil {
		return nil, errors.New("invalid value for required argument 'Metadata'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AttackRules
	err := ctx.RegisterResource("dynatrace:index/attackRules:AttackRules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAttackRules gets an existing AttackRules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAttackRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AttackRulesState, opts ...pulumi.ResourceOption) (*AttackRules, error) {
	var resource AttackRules
	err := ctx.ReadResource("dynatrace:index/attackRules:AttackRules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AttackRules resources.
type attackRulesState struct {
	// Step 2: Define attack control for chosen criteria
	AttackHandling *AttackRulesAttackHandling `pulumi:"attackHandling"`
	// Step 1: Define criteria
	Criteria *AttackRulesCriteria `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled *bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Step 3: Leave comment
	Metadata *AttackRulesMetadata `pulumi:"metadata"`
}

type AttackRulesState struct {
	// Step 2: Define attack control for chosen criteria
	AttackHandling AttackRulesAttackHandlingPtrInput
	// Step 1: Define criteria
	Criteria AttackRulesCriteriaPtrInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolPtrInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Step 3: Leave comment
	Metadata AttackRulesMetadataPtrInput
}

func (AttackRulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*attackRulesState)(nil)).Elem()
}

type attackRulesArgs struct {
	// Step 2: Define attack control for chosen criteria
	AttackHandling AttackRulesAttackHandling `pulumi:"attackHandling"`
	// Step 1: Define criteria
	Criteria AttackRulesCriteria `pulumi:"criteria"`
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled bool `pulumi:"enabled"`
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter *string `pulumi:"insertAfter"`
	// Step 3: Leave comment
	Metadata AttackRulesMetadata `pulumi:"metadata"`
}

// The set of arguments for constructing a AttackRules resource.
type AttackRulesArgs struct {
	// Step 2: Define attack control for chosen criteria
	AttackHandling AttackRulesAttackHandlingInput
	// Step 1: Define criteria
	Criteria AttackRulesCriteriaInput
	// This setting is enabled (`true`) or disabled (`false`)
	Enabled pulumi.BoolInput
	// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
	InsertAfter pulumi.StringPtrInput
	// Step 3: Leave comment
	Metadata AttackRulesMetadataInput
}

func (AttackRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*attackRulesArgs)(nil)).Elem()
}

type AttackRulesInput interface {
	pulumi.Input

	ToAttackRulesOutput() AttackRulesOutput
	ToAttackRulesOutputWithContext(ctx context.Context) AttackRulesOutput
}

func (*AttackRules) ElementType() reflect.Type {
	return reflect.TypeOf((**AttackRules)(nil)).Elem()
}

func (i *AttackRules) ToAttackRulesOutput() AttackRulesOutput {
	return i.ToAttackRulesOutputWithContext(context.Background())
}

func (i *AttackRules) ToAttackRulesOutputWithContext(ctx context.Context) AttackRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackRulesOutput)
}

// AttackRulesArrayInput is an input type that accepts AttackRulesArray and AttackRulesArrayOutput values.
// You can construct a concrete instance of `AttackRulesArrayInput` via:
//
//	AttackRulesArray{ AttackRulesArgs{...} }
type AttackRulesArrayInput interface {
	pulumi.Input

	ToAttackRulesArrayOutput() AttackRulesArrayOutput
	ToAttackRulesArrayOutputWithContext(context.Context) AttackRulesArrayOutput
}

type AttackRulesArray []AttackRulesInput

func (AttackRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttackRules)(nil)).Elem()
}

func (i AttackRulesArray) ToAttackRulesArrayOutput() AttackRulesArrayOutput {
	return i.ToAttackRulesArrayOutputWithContext(context.Background())
}

func (i AttackRulesArray) ToAttackRulesArrayOutputWithContext(ctx context.Context) AttackRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackRulesArrayOutput)
}

// AttackRulesMapInput is an input type that accepts AttackRulesMap and AttackRulesMapOutput values.
// You can construct a concrete instance of `AttackRulesMapInput` via:
//
//	AttackRulesMap{ "key": AttackRulesArgs{...} }
type AttackRulesMapInput interface {
	pulumi.Input

	ToAttackRulesMapOutput() AttackRulesMapOutput
	ToAttackRulesMapOutputWithContext(context.Context) AttackRulesMapOutput
}

type AttackRulesMap map[string]AttackRulesInput

func (AttackRulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttackRules)(nil)).Elem()
}

func (i AttackRulesMap) ToAttackRulesMapOutput() AttackRulesMapOutput {
	return i.ToAttackRulesMapOutputWithContext(context.Background())
}

func (i AttackRulesMap) ToAttackRulesMapOutputWithContext(ctx context.Context) AttackRulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AttackRulesMapOutput)
}

type AttackRulesOutput struct{ *pulumi.OutputState }

func (AttackRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AttackRules)(nil)).Elem()
}

func (o AttackRulesOutput) ToAttackRulesOutput() AttackRulesOutput {
	return o
}

func (o AttackRulesOutput) ToAttackRulesOutputWithContext(ctx context.Context) AttackRulesOutput {
	return o
}

// Step 2: Define attack control for chosen criteria
func (o AttackRulesOutput) AttackHandling() AttackRulesAttackHandlingOutput {
	return o.ApplyT(func(v *AttackRules) AttackRulesAttackHandlingOutput { return v.AttackHandling }).(AttackRulesAttackHandlingOutput)
}

// Step 1: Define criteria
func (o AttackRulesOutput) Criteria() AttackRulesCriteriaOutput {
	return o.ApplyT(func(v *AttackRules) AttackRulesCriteriaOutput { return v.Criteria }).(AttackRulesCriteriaOutput)
}

// This setting is enabled (`true`) or disabled (`false`)
func (o AttackRulesOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *AttackRules) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Because this resource allows for ordering you may specify the ID of the resource instance that comes before this instance regarding order. If not specified when creating the setting will be added to the end of the list. If not specified during update the order will remain untouched
func (o AttackRulesOutput) InsertAfter() pulumi.StringOutput {
	return o.ApplyT(func(v *AttackRules) pulumi.StringOutput { return v.InsertAfter }).(pulumi.StringOutput)
}

// Step 3: Leave comment
func (o AttackRulesOutput) Metadata() AttackRulesMetadataOutput {
	return o.ApplyT(func(v *AttackRules) AttackRulesMetadataOutput { return v.Metadata }).(AttackRulesMetadataOutput)
}

type AttackRulesArrayOutput struct{ *pulumi.OutputState }

func (AttackRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AttackRules)(nil)).Elem()
}

func (o AttackRulesArrayOutput) ToAttackRulesArrayOutput() AttackRulesArrayOutput {
	return o
}

func (o AttackRulesArrayOutput) ToAttackRulesArrayOutputWithContext(ctx context.Context) AttackRulesArrayOutput {
	return o
}

func (o AttackRulesArrayOutput) Index(i pulumi.IntInput) AttackRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AttackRules {
		return vs[0].([]*AttackRules)[vs[1].(int)]
	}).(AttackRulesOutput)
}

type AttackRulesMapOutput struct{ *pulumi.OutputState }

func (AttackRulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AttackRules)(nil)).Elem()
}

func (o AttackRulesMapOutput) ToAttackRulesMapOutput() AttackRulesMapOutput {
	return o
}

func (o AttackRulesMapOutput) ToAttackRulesMapOutputWithContext(ctx context.Context) AttackRulesMapOutput {
	return o
}

func (o AttackRulesMapOutput) MapIndex(k pulumi.StringInput) AttackRulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AttackRules {
		return vs[0].(map[string]*AttackRules)[vs[1].(string)]
	}).(AttackRulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AttackRulesInput)(nil)).Elem(), &AttackRules{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttackRulesArrayInput)(nil)).Elem(), AttackRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AttackRulesMapInput)(nil)).Elem(), AttackRulesMap{})
	pulumi.RegisterOutputType(AttackRulesOutput{})
	pulumi.RegisterOutputType(AttackRulesArrayOutput{})
	pulumi.RegisterOutputType(AttackRulesMapOutput{})
}
